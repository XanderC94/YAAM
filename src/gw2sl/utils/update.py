'''
GW2SL utility module
'''

import os

from enum import Enum
from pathlib import Path

import requests

from utils.hashing import get_local_hash, get_remote_hash
from objects.addon import Addon

class UpdateResult(Enum):
    '''
    Possible results of addon update
    '''
    NOT_DLL = -2,
    DELETED = -1,
    DISABLED = 0,
    CREATED = 1,
    UPDATED = 2,
    UP_TO_DATE = 3,

def restore_addons(bin_dir: Path):
    '''
    Restore backup folder with active addons.

    @bin_dir : Path -- The current directory where the .dll addons are stored.
    '''

    ret: bool = False

    arc_bak_dir: Path = bin_dir.parent / f"{bin_dir.name}.arc.bak"
    def_bak_dir: Path = bin_dir.parent / f"{bin_dir.name}.bak"

    if arc_bak_dir.exists():
        print("ArcDPS will be restored...")

        if not def_bak_dir.exists():
            os.rename(str(bin_dir), str(def_bak_dir))

        os.rename(str(arc_bak_dir), str(bin_dir))

        ret = True

    return ret


def disable_addons(bin_dir: Path):
    '''
    Backup the current addon folder and restore a vanilla version.
    If a vanilla version is not present, it will be generated by the game.
    @bin_dir : Path -- The vanilla bin directory.
    '''

    ret = False

    arc_bak_dir: Path = bin_dir.parent() / f"{bin_dir.name}.arc.bak"
    def_bak_dir: Path = bin_dir.parent() / f"{bin_dir.name}.bak"

    if not arc_bak_dir.exists():
        print("ArcDPS will be suppressed...")

        os.rename(str(bin_dir), str(arc_bak_dir))

        if def_bak_dir.exists():
            os.rename(str(def_bak_dir), str(bin_dir))

        ret = True

    return ret

def update_addon(addon: Addon):
    '''
    Update where specified or possible the provided addon

    @addon: dict -- addon to updated
    '''

    ret_code = UpdateResult.NOT_DLL

    if addon.is_dll():

        ret_code = UpdateResult.DISABLED

        if addon.path.exists():

            if addon.update:

                print(f"Updating {addon.name}({addon.path.suffix})...")

                remote_hash, hash_type = get_remote_hash(addon.hash_url)
                print(f"Remote hash is {remote_hash}")

                local_hash = get_local_hash(addon.path, hash_type)
                print(f"Local hash is {local_hash}")

                if remote_hash == local_hash:

                    print("Addon is up-to-date.")
                    ret_code = UpdateResult.UP_TO_DATE

                else:

                    print("New addon update found. Downloading...")
                    res = requests.get(addon.update_url)

                    # write file on disk
                    with open(addon.path, 'wb') as addon_file:
                        addon_file.write(res.content)

                    ret_code = UpdateResult.UPDATED

            elif not addon.enabled:

                print(f"Addon {addon.name} is disabled, will be removed...")

                os.remove(addon.path)
                ret_code = UpdateResult.DELETED

        elif addon.enabled:

            print(f"Creating {addon.name}({addon.path.suffix})...")
            res = requests.get(addon.update_url)
            # write file on disk
            with open(addon.path, 'wb') as addon_file:
                addon_file.write(res.content)

            ret_code = UpdateResult.CREATED

    return ret_code

def update_addons(addons: list):
    '''
    Update where specified or possible the addons provided by the list

    @addons: list -- list of addons to updated
    '''

    for addon in addons:
        update_addon(addon)
