import hashlib
import requests
# from tqdm import tqdm
from enum import Enum
from pathlib import Path
import os, subprocess, time
from objects import Addon, AddonFactory

class UpdateResult:
    NOT_DLL = -2,
    DELETED = -1,
    DISABLED = 0,
    CREATED = 1,
    UPDATED = 2,
    UP_TO_DATE = 3,

class HashType(Enum):

    NONE    =    (-1,    set()                 ),
    MD5     =    (0,     set(['MD5', 'MD5SUM'])),
    SHA1    =    (1,     set(['SHA1'])         ),
    SHA256  =    (2,     set(['SHA256', 'SHA'])),
    SHA384  =    (3,     set(['SHA384'])       ),
    SHA512  =    (4,     set(['SHA512'])       )

    @staticmethod
    def from_string(estr: str):
        et = HashType.NONE

        for e in HashType:
            if estr.upper() in e.value[0][1]:
                et = e
                break

        return et

def Run(target: Path, workspace: Path, args: list = []):
    '''
    Run the target process in the specified workspace
    and the provided arguments.

    @target : Path -- process to run
    @workspace : Path -- workspace in which run the process
    @args : list -- list of command line parameters provided to the process
    '''
    print(f"Launching {target.stem}...")
    
    if len(args):
        print(f"Arguments: {args}")

    process = subprocess.Popen(executable=str(target), cwd=str(workspace), args=args)
    time.sleep(5)

def RestoreAddons(bin_dir: Path):
    '''
    Restore backup folder with active addons.

    @bin_dir : Path -- The current directory where the .dll addons are stored.
    '''
    ret : bool = False

    arc_bak_dir : Path = bin_dir.parent / f"{bin_dir.name}.arc.bak"
    def_bak_dir : Path = bin_dir.parent / f"{bin_dir.name}.bak"
    
    if arc_bak_dir.exists():
        print("ArcDPS will be restored...")

        if not def_bak_dir.exists():
            os.rename(str(bin_dir), str(def_bak_dir))

        os.rename(str(arc_bak_dir), str(bin_dir))

        ret = True
    
    return ret


def DisableAddons(bin_dir: Path):
    '''
    Backup the current addon folder and restore a vanilla version.
    If a vanilla version is not present, it will be generated by the game.
    
    @bin_dir : Path -- The vanilla bin directory.
    '''

    ret : bool = False

    arc_bak_dir : Path = bin_dir.parent() / f"{bin_dir.name}.arc.bak"
    def_bak_dir : Path = bin_dir.parent() / f"{bin_dir.name}.bak"
    
    if not arc_bak_dir.exists():
        print("ArcDPS will be suppressed...")

        os.rename(str(bin_dir), str(arc_bak_dir))

        if def_bak_dir.exists():
            os.rename(str(def_bak_dir), str(bin_dir))

        ret = True
    
    return ret

def make_hash(fname, fshan = hashlib.md5()):
    with open(fname, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            fshan.update(chunk)
    return fshan.hexdigest()

def GetRemoteHash(url: str):
    '''
    Retreive a remote hash from the provided url

    @url: str -- address of the hash
    '''
    hash_code = str()
    hash_type = HashType.NONE

    tokens = url.split('.')
    
    if len(tokens):
        hash_type = HashType.from_string(tokens[-1])

    res = requests.get(url)
    hash_code = res.content.decode(encoding='utf-8', errors='ignore')

    split = ['\n', '\r', ' ']

    for s in split:

        tokens = hash_code.split(sep=s)
        for t in tokens:
            if len(t) > 0:
                hash_code = t
                break
    
    purge = ["\x00"]

    for c in purge:
        hash_code = hash_code.replace(c, "")

    return (hash_code.upper(), hash_type)

def GetLocalHash(path: Path, hash_type: HashType):
    '''
    Retreive a remote hash from the provided url

    @path: Path -- path to the file for which computing the hash
    '''
    hash_code = str()

    if hash_type == HashType.MD5:
        hash_code = make_hash(path)
    elif hash_type == HashType.SHA1:
        hash_code = make_hash(path, hashlib.sha1())
    elif hash_type == HashType.SHA256:
        hash_code = make_hash(path, hashlib.sha256())
    elif hash_type == HashType.SHA384:
        hash_code = make_hash(path, hashlib.sha384())
    elif hash_type == HashType.SHA512:
        hash_code = make_hash(path, hashlib.sha512())

    return hash_code.upper()

def UpdateAddon(addon: Addon):
    '''
    Update where specified or possible the provided addon

    @addon: dict -- addon to updated
    '''

    ret_code = UpdateResult.NOT_DLL


    if addon.is_dll():
 
        ret_code = UpdateResult.DISABLED

        if addon.path.exists():

            if addon.update:

                print(f"Updating {addon.name}({addon.path.suffix})...")
                
                remote_hash, hash_type = GetRemoteHash(addon.hash_url)
                print(f"Remote hash is {remote_hash}")
                local_hash = GetLocalHash(addon.path, hash_type)
                print(f"Local hash is {local_hash}")

                if remote_hash == local_hash:
                    print("Addon is up-to-date.")
                    ret_code = UpdateResult.UP_TO_DATE
                else:
                    print("New addon update found. Downloading...")
                    res = requests.get(addon.update_url)
                    # write file on disk
                    with open(addon.path, 'wb') as f:
                        f.write(res.content)
                    
                    ret_code = UpdateResult.UPDATED

            elif not addon.enabled:
                print(f"Addon {addon.name} is disabled, will be removed...")
                os.remove(addon.path)

                ret_code = UpdateResult.DELETED
        
        elif addon.enabled:
            print(f"Creating {addon.name}({addon.path.suffix})...")
            res = requests.get(addon.update_url)
            # write file on disk
            with open(addon.path, 'wb') as f:
                f.write(res.content)

            ret_code = UpdateResult.CREATED

    return ret_code

def UpdateAddons(addons: list):
    '''
    Update where specified or possible the addons provided by the list

    @addons: list -- list of addons to updated
    '''

    for addon in addons:
        UpdateAddon(addon)
